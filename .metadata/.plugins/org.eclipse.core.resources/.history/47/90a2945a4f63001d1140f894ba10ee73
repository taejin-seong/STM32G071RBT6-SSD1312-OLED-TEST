/*
 * gpio.c
 *
 *  Created on: Oct 30, 2022
 *      Author: user
 */


#include "gpio.h"




typedef struct
{
  GPIO_TypeDef *port;
  uint32_t      pin;
  uint8_t       mode;
  uint8_t       mode_state;
  bool          init_value;
} gpio_tbl_t;


const gpio_tbl_t gpio_tbl[GPIO_MAX_CH] =
    {
        {GPIOA, LL_GPIO_PIN_5,_DEF_INPUT_PULLUP, _DEF_OUTPUT_MODE_FLAG, true},  //USER LED
    };




bool gpioInit(void)
{
  bool ret = true;

  for (int i=0; i<GPIO_MAX_CH; i++)
  {
    gpioPinMode(i, gpio_tbl[i].mode, gpio_tbl[i].mode_state);
    gpioPinWrite(i, gpio_tbl[i].init_value);
  }
 return ret;
}


bool gpioPinMode(uint8_t ch, uint8_t mode, uint8_t mode_state)
{
  bool ret = true;
  LL_GPIO_InitTypeDef  GPIO_InitStruct = {0};


  if (ch >= GPIO_MAX_CH)
  {
    return false;
  }

  if (mode_state == _DEF_INPUT_MODE_FLAG)
  {
    switch(mode)
    {
      case _DEF_INPUT:
        GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
        GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
        break;

      case _DEF_INPUT_PULLUP:
        GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
        GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
        break;

      case _DEF_INPUT_PULLDOWN:
        GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
        GPIO_InitStruct.Pull = LL_GPIO_PULL_DOWN;
        break;
    }

  }
  else if (mode_state == _DEF_OUTPUT_MODE_FLAG)
  {
    // TODO: gpio output fix value..
    GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;

     switch(mode)
     {
       case _DEF_OUTPUT:
         GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
         GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
         GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
         GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
         break;

       case _DEF_OUTPUT_PULLUP:
         GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
         GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
         GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
         GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
         break;

       case _DEF_OUTPUT_PULLDOWN:
         GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
         GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
         GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
         GPIO_InitStruct.Pull = LL_GPIO_PULL_DOWN;
         break;
     }

  }

  GPIO_InitStruct.Pin = gpio_tbl[ch].pin;
  LL_GPIO_Init(gpio_tbl[ch].port, &GPIO_InitStruct);

  return ret;
}


void gpioPinWrite(uint8_t ch, bool value)
{
  if (ch >= GPIO_MAX_CH)
  {
    return;
  }

  if (value)
  {
    LL_GPIO_SetOutputPin(gpio_tbl[ch].port, gpio_tbl[ch].pin);
  }
  else
  {
    LL_GPIO_ResetOutputPin(gpio_tbl[ch].port, gpio_tbl[ch].pin);
  }
}

uint32_t gpioPinRead(uint8_t ch)
{
  if (ch >= GPIO_MAX_CH)
  {
    return false;
  }

  else
  {
    uint32_t input = LL_GPIO_ReadInputPort(gpio_tbl[ch].port);
    input &= gpio_tbl[ch].pin;

    return input;
  }
}


void gpioPinToggle(uint8_t ch)
{
  if (ch >= GPIO_MAX_CH)
  {
    return;
  }

  LL_GPIO_TogglePin(gpio_tbl[ch].port, gpio_tbl[ch].pin);
}
